(in-package :elo100)

(defparameter *quick-movescan-mode* nil)

(defun thing-test ()
  (let ((cow 0))
    (time (dotimes (i 10000000) (setf cow (+ cow (piece-at *clean-state* 4 3)))))
    (let* ((fixnum-size (integer-length most-negative-fixnum))
           (small-board (ldb (byte fixnum-size +board-offset+) *clean-state*))
           (cow 0))
      (time (dotimes (i 10000000) (setf cow (+ cow (piece-at small-board 0 0))))))))

(defun move-scan (moves board color coord coord-d capture require-capture max-manhat)
  (let ((keep-searching T)
        (moves moves)
        (o-x (x coord))
        (o-y (y coord))
        (cur-x (x coord))
        (cur-y (y coord))
        (d-x (x coord-d))
        (d-y (y coord-d)))
    (declare (type fixnum cur-x d-x cur-y d-y o-x o-y max-manhat))
    (setf cur-x (+ cur-x d-x))
    (setf cur-y (+ cur-y d-y))
    (loop while (and keep-searching
                     (not (and *quick-movescan-mode* moves))
                     (d-in-bounds-p cur-x cur-y)
                     (<= (d-manhat o-x o-y cur-x cur-y) max-manhat)) do
         (let ((piece (piece-at board cur-x cur-y)))
           (if (not (= piece 0))
               (progn
                 (cond
                   ((not capture)
                    (setf keep-searching nil))
                   ((eql color (piece-color piece))
                    (setf keep-searching nil))
                   (T (setf keep-searching nil)
                      (setf moves (cons (cons coord (cons cur-x cur-y)) moves)))))
               (when (not require-capture)
                 (setf moves (cons (cons coord (cons cur-x cur-y)) moves)))))
         (setf cur-x (+ cur-x d-x))
         (setf cur-y (+ cur-y d-y)))
    moves))

(defun mover (action directions moves)
  (reduce action directions :initial-value moves))

(defgeneric inner-move-list (board color coord moves piece-class))
(defmethod inner-move-list (board color coord moves piece-class) moves)

(defmethod inner-move-list (board color coord moves (piece-class (eql +knight+)))
  (mover (lambda (moves direction)
           (move-scan moves board color coord direction T nil 3))
         '((-1 . 2) (1 . 2)   (2 . 1)   (2 . -1)
           (1 . -2) (-1 . -2) (-2 . -1) (-2 . 1)) moves))

(defmethod inner-move-list (board color coord moves (piece-class (eql +rook+)))
  (mover (lambda (moves direction)
           (move-scan moves board color coord direction T nil 99))
         '((1 . 0) (-1 . 0) (0 . 1) (0 . -1)) moves))

(defmethod inner-move-list (board color coord moves (piece-class (eql +queen+)))
  (mover (lambda (moves direction)
           (move-scan moves board color coord direction T nil 99))
         '((-1 . 1) (0 . 1) (1 . 1)
           (-1 . 0)         (1 . 0)
           (-1 . -1)(0 . -1)(1 . -1)) moves))

(defmethod inner-move-list (board color coord moves (piece-class (eql +king+)))
  (let ((moves moves))
    (setf moves (mover (lambda (moves direction)
                         (move-scan moves board color coord direction T nil 1))
                       '((1 . 0) (-1 . 0) (0 . 1) (0 . -1)) moves))
    (when (and *quick-movescan-mode* moves) (return-from inner-move-list moves))
    (setf moves (mover (lambda (moves direction)
                         (move-scan moves board color coord direction T nil 2))
                       '((-1 . -1) (1 . -1) (-1 . 1) (1 . 1)) moves))
    moves))

(defmethod inner-move-list (board color coord moves (piece-class (eql +bishop+)))
  (let ((moves moves))
    (setf moves (mover (lambda (moves direction)
                         (move-scan moves board color coord direction T nil 99))
                       '((-1 . -1) (1 . -1) (-1 . 1) (1 . 1)) moves))
    (when (and *quick-movescan-mode* moves) (return-from inner-move-list moves))
    (setf moves (mover (lambda (moves direction)
                         (move-scan moves board color coord direction nil nil 1))
                       '((1 . 0) (-1 . 0) (0 . 1) (0 . -1)) moves))
    moves))

(defmethod inner-move-list (board color coord moves (piece-class (eql +pawn+)))
  (let ((color (color-at board (x coord) (y coord)))
        (moves moves))
    (setf moves (mover (lambda (moves direction)
                         (move-scan moves board color coord direction T T 2))
                       (if (eql color +white+)
                           '((1 . -1) (-1 . -1))
                           '((1 . 1) (-1 . 1))) moves))
    (when (and *quick-movescan-mode* moves) (return-from inner-move-list moves))
    (mover (lambda (moves direction)
             (move-scan moves board color coord direction nil nil 1))
           (if (eql color +white+) '((0 . -1)) '((0 . 1))) moves)))

(defun move-list (state x y moves)
  (inner-move-list state (color-at state x y) (cons x y) moves (piece-class (piece-at state x y))))

(defun possible-moves (state &optional quick-mode)
  (let* ((*quick-movescan-mode* quick-mode)
        (color (game-state-on-move state))
        (half-board-size (* 15 +piece-size+))
        (board-a (ldb (byte half-board-size +board-offset+) state))
        (board-b (ldb (byte half-board-size (+ +board-offset+
                                               half-board-size)) state))
        (moves ()))
    (loop for y from 0 to 5 do
         (loop for x from 0 to 4 do
              (let* ((piece (piece-at state x y))
                     (spot-color (piece-color piece)))
                (when (eql color spot-color)
                  (setf moves (move-list state x y moves))
                  (when (and *quick-movescan-mode* moves) (return-from possible-moves moves))))))
    moves))
